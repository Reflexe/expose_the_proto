#!/usr/bin/env python3
import sys

from google.protobuf.compiler import plugin_pb2 as plugin
from google.protobuf.compiler.plugin_pb2 import CodeGeneratorRequest
from google.protobuf.descriptor import FieldDescriptor, FileDescriptor
from google.protobuf.descriptor_pb2 import DescriptorProto, FieldDescriptorProto

from analyze.symbols import Symbols
from analyze.table import Table


class CodeGenerator:
    def generate(self):
        raise NotImplementedError()


class KotlinGenerator(CodeGenerator):
    pass


class ProtoGenerator:
    """
    Generate kotlin exposed code objects from
    protobuf messages.
    Implement also type safty and validation.
    We should also make it possible to retrive fields
    dynamically. (e.g. like we did in the search function).

    1. Figure out how to generate the code.
    2. Figure out how to choose types to generate.


    3. Support .value fields.
    4. Support standard fields.
    5. Figure out how to retrieve dynamically typed fields.
    6. Generate the least possible code.
    7. Figure out how to customize the generation output (e.g. change package,
        use one message for multiple tables.
    """

    _ID_TABLE_TEMPLATE = '''\
object {name}Table (IntIdTable) {
    {fields}
}   
'''

    _TABLE_FIELD_TEMPLATE = "val {name} = {database_type}(name = \"{name}\")"

    _CPPTYPE_TO_DATABASE_TYPE = {
        FieldDescriptor.CPPTYPE_DOUBLE: "double",
        FieldDescriptor.CPPTYPE_BOOL: "bool",
        FieldDescriptor.CPPTYPE_ENUM: "enum",
        FieldDescriptor.CPPTYPE_FLOAT: "float",
        FieldDescriptor.CPPTYPE_INT32: "int",
        FieldDescriptor.CPPTYPE_INT64: "int",
        FieldDescriptor.CPPTYPE_STRING: "string",
        # TODO: should't be unsigned?
        FieldDescriptor.CPPTYPE_UINT32: "int",
        FieldDescriptor.CPPTYPE_UINT64: "int",

        # Message should be handled specially and not here.
        # FieldDescriptor.CPPTYPE_MESSAGE: ""
    }

    def __init__(self, request: CodeGeneratorRequest, response):
        self._content = []
        self._imports = set()
        self._request = request
        self._response = response
        self._symbols = Symbols(request)

    # TODO: allow custom conversions.
    def database_type_from_field(self, field: FieldDescriptorProto):
        database_type = self._CPPTYPE_TO_DATABASE_TYPE.get(field.type)

        # TODO: support enum
        # TODO: in case of a ID message inside another message,
        #       use `references` to the other ID.'
        # TODO: define options for skipping
        #       and for messages relationships.
        # This is a message field. Look for "value" field.
        if not database_type:
            if field.type_name[0] == '.':
                # Resolve fully qualified name
                message_type = self._symbols.lookup(field.type_name)
            else:
                # resolve from local package.
                message_type = self._symbols.lookup(field.type_name, field.package)

            if not message_type:
                raise ValueError("Could not find name: {}".format(field.type_name))

            value_field = list(filter(
                lambda message_field: message_field.name == "value",
                message_type.field
            ))

            if not value_field:
                raise ValueError("could not find a database value for "
                                 "{field_name}".format(field_name=field.name))
            else:
                return self.database_type_from_field(value_field.pop())

        return database_type

    _TABLE_FILE_TEMPLATE = '''
# Generated by expose_the_proto.py
    
package {package}
    
{imports}
    
{tables}
'''

    _MESSAGE_TEMPLATE = '''
object {name}Table : {table_type} {{
    {fields}
}}'''

    def _generate_table_from_message(self, message: DescriptorProto):
        table_type = "Table"
        # TODO: god i hate that
        lines = []

        for field in message.field:
            if self._is_id_field(field):
                table_type = "IntIdTable"
                continue

            lines.append(self._generate_table_field(field))

        # TODO: variables instead of magic values
        if table_type == "IntIdTable":
            self._add_import("org.jetbrains.exposed.dao.IntIdTable")
        else:
            self._add_import("org.jetbrains.exposed.dao.Table")

        return self._MESSAGE_TEMPLATE.format(
            name=message.name,
            table_type=table_type,
            fields='\n    '.join(lines),
        )

    def generate_proto_file(self, proto_file: FileDescriptor):
        # TODO: make package optional
        file_content = self._TABLE_FILE_TEMPLATE.format(
            package=proto_file.package,
            imports='\n'.join(self._imports),
            tables=''.join(self._generate_table_from_message(message) for message in proto_file.message_type)
        )

        # Fill response
        f = self._response.file.add()

        f.name = proto_file.name + '.kt'
        f.content = file_content

    def generate(self):
        for proto_file in self._request.proto_file:
            self.generate_proto_file(proto_file)

    def _add_import(self, param):
        self._imports.add(param)

    def _generate_table_field(self, field):
        return self._TABLE_FIELD_TEMPLATE.format(
            name=field.name,
            database_type=self.database_type_from_field(field)
        )

    def _is_id_field(self, field):
        return field.name in ("ID", "Id", "id") and self.database_type_from_field(field) in ("int", "long")

    def _add_line(self, line):
        self._content.append(line)

    def generate_tables(self):
        for proto_file in self._request.proto_file:
            for message in proto_file.message_type:
                symbol = self._symbols.lookup(message.name, message.package)

                symbol.table = Table()
                for field in message.field:
                    symbol.table.add_field(Table.Field(field_name=field.name,
                                                       field_type=self.database_type_from_field(field)))


    # First pass: just generate Table and non referencing fields.
    # Second pass: Generate referencing fields.

def main():
    # Read request message from stdin
    data = sys.stdin.buffer.read()

    # Parse request
    request = plugin.CodeGeneratorRequest()
    request.ParseFromString(data)

    # Create response
    response = plugin.CodeGeneratorResponse()

    # Generate code
    generator = ProtoGenerator(request, response)
    generator.generate()

    # Serialise response message
    output = response.SerializeToString()

    # Write to stdout
    sys.stdout.buffer.write(output)


if __name__ == '__main__':
    main()
